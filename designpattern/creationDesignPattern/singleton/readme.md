Sure! Hereâ€™s a table summarizing the top 4 commonly used creational design patterns, including their purpose, usage, and examples in Go:

| Pattern           | Purpose                                                                 | Usage                                                                                               | Example Code Snippet                                                                                          |
|-------------------|-------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Singleton**     | Ensures a class has only one instance and provides a global point of access to it. | Useful for managing shared resources such as configuration settings, logging instances, and connection pools. | ```go<br>package main<br><br>import (<br>"fmt"<br>"sync"<br>)<br><br>type Singleton struct{}<br><br>var instance *Singleton<br>var once sync.Once<br><br>func GetInstance() *Singleton {<br>once.Do(func() {<br>instance = &Singleton{}<br>})<br>return instance<br>}<br><br>func main() {<br>s1 := GetInstance()<br>s2 := GetInstance()<br><br>if s1 == s2 {<br>fmt.Println("Both instances are the same")<br>}<br>}<br>``` |
| **Factory Method** | Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created. | Useful for creating objects when the exact type is determined at runtime or for managing object creation based on certain conditions. | ```go<br>package main<br><br>import "fmt"<br><br>type Animal interface {<br>Speak() string<br>}<br><br>type Dog struct{}<br><br>func (d Dog) Speak() string {<br>return "Woof!"<br>}<br><br>type Cat struct{}<br><br>func (c Cat) Speak() string {<br>return "Meow!"<br>}<br><br>type AnimalFactory struct{}<br><br>func (af *AnimalFactory) CreateAnimal(animalType string) Animal {<br>if animalType == "dog" {<br>return &Dog{}<br>} else if animalType == "cat" {<br>return &Cat{}<br>}<br>return nil<br>}<br><br>func main() {<br>factory := AnimalFactory{}<br>dog := factory.CreateAnimal("dog")<br>cat := factory.CreateAnimal("cat")<br><br>fmt.Println(dog.Speak()) // Output: Woof!<br>fmt.Println(cat.Speak()) // Output: Meow!<br>}<br>``` |
| **Abstract Factory** | Provides an interface for creating families of related or dependent objects without specifying their concrete classes. | Useful for systems that need to be independent of how their products are created, composed, and represented. | ```go<br>package main<br><br>import "fmt"<br><br>type Button interface {<br>Render()<br>}<br><br>type WinButton struct{}<br><br>func (b *WinButton) Render() {<br>fmt.Println("Rendering Windows button")<br>}<br><br>type MacButton struct{}<br><br>func (b *MacButton) Render() {<br>fmt.Println("Rendering Mac button")<br>}<br><br>type GUIFactory interface {<br>CreateButton() Button<br>}<br><br>type WinFactory struct{}<br><br>func (f *WinFactory) CreateButton() Button {<br>return &WinButton{}<br>}<br><br>type MacFactory struct{}<br><br>func (f *MacFactory) CreateButton() Button {<br>return &MacButton{}<br>}<br><br>func main() {<br>var factory GUIFactory<br><br>os := "windows"<br>if os == "windows" {<br>factory = &WinFactory{}<br>} else if os == "mac" {<br>factory = &MacFactory{}<br>}<br><br>button := factory.CreateButton()<br>button.Render()<br>}<br>``` |
| **Builder**       | Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. | Useful for creating complex objects with many parts, especially when there are multiple ways to construct an object. | ```go<br>package main<br><br>import "fmt"<br><br>type House struct {<br>Windows string<br>Doors string<br>Roof string<br>}<br><br>type HouseBuilder interface {<br>SetWindows(windows string) HouseBuilder<br>SetDoors(doors string) HouseBuilder<br>SetRoof(roof string) HouseBuilder<br>Build() House<br>}<br><br>type ConcreteHouseBuilder struct {<br>house House<br>}<br><br>func (b *ConcreteHouseBuilder) SetWindows(windows string) HouseBuilder {<br>b.house.Windows = windows<br>return b<br>}<br><br>func (b *ConcreteHouseBuilder) SetDoors(doors string) HouseBuilder {<br>b.house.Doors = doors<br>return b<br>}<br><br>func (b *ConcreteHouseBuilder) SetRoof(roof string) HouseBuilder {<br>b.house.Roof = roof<br>return b<br>}<br><br>func (b *ConcreteHouseBuilder) Build() House {<br>return b.house<br>}<br><br>func main() {<br>builder := &ConcreteHouseBuilder{}<br>house := builder.SetWindows("Double Pane").<br>SetDoors("Wooden").<br>SetRoof("Shingle").<br>Build()<br><br>fmt.Printf("House with %s windows, %s doors, and %s roof\n",<br>house.Windows, house.Doors, house.Roof)<br>}<br>``` |

---

This table provides a concise summary of the top 4 creational design patterns, their purposes, usage scenarios, and example code snippets in Go.